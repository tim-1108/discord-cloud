import { ref, type Ref } from "vue";
import { ThumbnailRequestPacket } from "../../../common/packet/c2s/ThumbnailRequestPacket";
import { GenericBooleanPacket } from "../../../common/packet/generic/GenericBooleanPacket";
import { getOrCreateCommunicator } from "./authentication";

const cache = new Map<number, Ref<Blob>>();

/**
 * Requests the url of the thumbnail for the file of the id.
 * Only send a request if you know that the file should have
 * a thumbnail (`has_thumbnail = true`) and that the user
 * actually has reading permissions (`ownership.status` is not `restricted`)
 */
async function requestUrl(id: number): Promise<string | null> {
    const c = await getOrCreateCommunicator();
    const reply = await c.sendPacketAndReply(new ThumbnailRequestPacket({ id }), GenericBooleanPacket);
    if (!reply) {
        return null;
    }
    // In a success case, message is used to communicate the link
    const { success, message } = reply.getData();
    if (!success || !message || !URL.canParse(message)) {
        return null;
    }
    return message;
}

async function fetchThumbnail(link: string): Promise<Blob | null> {
    try {
        const response = await fetch(link);
        // The response of this should always be a avif image,
        // as that is what is generated by the thumbnail service.
        if (!response.ok || response.headers.get("content-type") !== "image/avif") {
            return null;
        }

        return response.blob();
    } catch {
        return null;
    }
}

async function get(id: number): Promise<Ref<Blob> | null> {
    const hit = cache.get(id);
    if (hit) {
        return hit;
    }

    const link = await requestUrl(id);
    if (!link) {
        return null;
    }

    const blob = await fetchThumbnail(link);
    if (!blob) {
        return null;
    }
    const val = ref(blob);
    cache.set(id, val);
    return val;
}

function invalidate(id: number) {
    return cache.delete(id);
}

/**
 * Overwrites the cached thumbnail blob to a new link.
 * Useful when thumbnail containers have the active ref
 * and the file is updated. That should be reflected in
 * the changing of the rendered thumbnail.
 *
 * If the thumbnail is not cached, it will not be downloaded
 * upon calling this function. If it were, files being uploaded
 * in folders the user is not viewing would result in them
 * downloading thumbnails for files they may never look at.
 * Only when `get` is called will the thumbnail be actually
 * fetched (like when a thumbnail container is mounted/in view)
 */
async function overwrite(id: number, link: string): Promise<boolean> {
    const hit = cache.get(id);
    if (!hit) {
        return false;
    }
    const blob = await fetchThumbnail(link);
    if (!blob) {
        return false;
    }
    hit.value = blob;
    return true;
}

export const Thumbnails = {
    requestUrl,
    get,
    invalidate,
    overwrite
} as const;
